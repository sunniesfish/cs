# 메모리 구조와 JavaScript의 GC (가비지 컬렉션) 관리

## 1. 메모리 구조의 기본 개념

### (1) 상위주소와 하위주소

- **상위주소와 하위주소**는 메모리 주소값을 구분하는 데 사용하는 용어로, **상대적인 물리적 개념**은 아님.
  - **상위주소**: 더 큰 주소값 (예: 메모리 상단 영역).
  - **하위주소**: 더 작은 주소값 (예: 메모리 하단 영역).

### (2) 메모리 영역

- **코드(텍스트)**: 실행 파일의 코드가 저장되는 메모리 영역.
- **데이터**: 초기화된 전역 변수, 정적 변수.
- **BSS**: 초기화되지 않은 전역 변수, 정적 변수.
- **힙(Heap)**: 동적 메모리 할당에 사용되는 영역. 위쪽으로 증가.
- **스택(Stack)**: 함수 호출 시 지역 변수와 반환 주소 저장. 아래쪽으로 감소.

#### 상위/하위 주소 요약

```
높은 주소
+-------------------+
|   스택 영역       |  → 함수 호출 시 데이터 증가
+-------------------+
|        힙         |  → 동적 메모리 할당 증가
+-------------------+
| 초기화 안 된 변수 (BSS) |
+-------------------+
| 초기화 된 데이터  |
+-------------------+
|   코드 영역       |
+-------------------+
낮은 주소

```

### (3) 논리적/물리적 연결

- 메모리 영역은 논리적 개념으로 운영체제가 관리.
  - 예: 가상 메모리 주소는 **프로세스별로 독립적**.
  - 물리 메모리와의 매핑은 페이지 테이블을 통해 이루어짐.

## 2. 가상 메모리

### (1) 정의와 개념

- 가상 메모리는 제한된 물리 메모리의 확장을 위해 **보조기억장치와 물리 메모리를 결합하여** 사용하는 기법.
- 주의: 가상 메모리는 단순히 보조기억장치를 램처럼 사용하는 개념이 아님. 프로그램은 가상 주소를 사용하고, 운영체제가 이를 물리 메모리에 매핑.

### (2) 동작 원리

- **페이지 테이블**을 활용:
  - 가상 메모리 주소를 **물리적 메모리 주소로 변환**.
  - 각 프로세스는 **고유한 가상 주소 공간**을 가짐.
- 필요한 경우 **스왑**:
  - 자주 사용하지 않는 데이터는 디스크로 옮겨 메모리를 확보.

### (3) 프로세스 별 동일한 가상 주소 사용

- 각 프로세스는 동일한 가상 주소를 가질 수 있음.
- 프로세스별 페이지 테이블에 의해 물리 메모리 매핑이 독립적임.

### (4) 시스템 콜과 가상 메모리

- 프로그램 파일이 실행되면, 운영체제는 가상 메모리를 초기화하는 시스템 콜을 호출:
  - **execve()**: 실행 파일 로딩 시 가상 메모리 구조를 초기화.
  - 페이지 테이블이 설정되고, 필요 시 물리 메모리와 매핑.

## 3. 페이징

### (1) 개념

- 물리 메모리를 일정한 크기의 블록(페이지 프레임)으로 나눔.
- 가상 메모리도 동일한 크기의 블록(페이지)으로 나눠 매핑.

### (2) 장점

- 메모리 조각화(fragmentation)를 방지.
- 필요한 메모리만 로드해 효율적인 메모리 사용 가능.

### (3) 페이징 처리 과정

1. CPU는 가상 주소를 요청.
2. 페이지 테이블에서 해당 가상 주소에 매핑된 물리 주소 검색.
3. 페이지 히트:
   - 매핑된 페이지가 메모리에 있으면 바로 접근.
4. 페이지 폴트:
   - 매핑된 페이지가 메모리에 없으면 디스크에서 불러옴.

### (4) 운영체제의 역할

- 커널 모드에서 페이지 테이블을 생성, 관리.
- 사용하지 않는 페이지를 디스크로 스왑하거나 필요한 페이지를 물리 메모리로 로드.
- 메모리 보호 기법으로 각 프로세스의 페이지 테이블을 격리.

## 4. JavaScript와 메모리 관리

### (1) JavaScript에서의 가비지 컬렉션(GC)

- JavaScript는 **자동 메모리 관리**를 제공하며, 개발자가 직접적으로 GC를 제어할 수 없음.
- 주요 알고리즘: **Mark-and-Sweep**.
  - **Mark**: 참조되는 객체를 "활성" 상태로 표시.
  - **Sweep**: 참조되지 않는 객체를 메모리에서 해제.

### (2) 간접적으로 GC 최적화 방법

1. **불필요한 참조 제거**:
   ```javascript
   let obj = { key: "value" };
   obj = null; // 참조 해제
   ```
2. **전역 객체 사용 최소화**:
   ```javascript
   function scopeExample() {
     let temp = "local variable";
   }
   ```
3. **객체 풀링 사용**:
   ```javascript
   const pool = [];
   function getObject() {
     return pool.length > 0 ? pool.pop() : {};
   }
   function releaseObject(obj) {
     pool.push(obj);
   }
   ```

### (3) Node.js에서 GC 강제 호출 (실험적)

- `--expose-gc` 플래그를 사용해 강제 호출:

  ```bash
  node --expose-gc app.js
  ```

  ```javascript
  global.gc();
  console.log("GC executed.");
  ```

- 단점: 잦은 호출은 성능 저하를 초래할 수 있음.

### (4) JavaScript와 가상 메모리

- JavaScript는 실제 메모리 할당과 해제를 개발자가 명시하지 않아도, 런타임 엔진(V8)이 관리.
- JavaScript 런타임이 실행되는 프로세스마다 고유한 가상 메모리 공간을 가짐.
  - 메모리 누수 방지: 이벤트 리스너 미제거, 클로저 등의 불필요한 참조를 조심.

### (5) 가비지 컬렉션과 페이지 테이블

- JavaScript에서 사용하는 힙 메모리는 가상 주소로 관리되며, 필요 시 물리 메모리에 매핑.
- GC 과정 중 참조되지 않는 객체는 해제되고 페이지 폴트가 발생하지 않도록 최적화.

## 5. 결론

### 운영체제와 JavaScript 메모리 관리의 핵심

- 운영체제:
  - 가상 메모리와 페이지 테이블을 통해 물리 메모리와 독립적인 프로세스 실행 가능.
  - 시스템 콜을 사용해 메모리 할당을 관리.
- JavaScript:
  - 가비지 컬렉터가 자동으로 메모리를 관리하며, 개발자는 효율적인 코딩으로 GC 부하를 줄이는 것이 중요.

---
