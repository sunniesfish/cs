# 질문-답변 정리 문서

## 1. SSR (서버 사이드 렌더링)

### Q1. SSR 프레임워크에서 Hydration이란 무엇인가?

**A:** Hydration은 서버에서 렌더링된 HTML을 클라이언트 측 React DOM과 연결(sync)하는 과정으로, 서버가 렌더링한 정적인 HTML에 클라이언트에서 React의 동적 기능(이벤트 핸들러 등)을 추가하는 작업입니다. 이 과정은 HTML 문서를 클라이언트가 처음 로드한 후 JavaScript가 실행되면서 시작됩니다. Hydration 과정에서 서버와 클라이언트가 동일한 UI 상태를 유지해야 하며, 상태가 일치하지 않으면 React는 경고 메시지를 출력하고 DOM을 재구성할 수 있습니다. 이를 방지하려면 서버와 클라이언트에서 동일한 데이터를 사용해야 합니다.

### Q2. SSR의 단점은?

**A:**

1. **서버 부하 증가**: 모든 요청에서 서버가 HTML을 생성해야 하므로 서버 자원이 많이 소모됩니다. 특히 트래픽이 높은 경우 서버 스케일링이 필수적입니다.
2. **첫 번째 요청 지연**: 서버에서 HTML을 생성해 전달하므로 TTFB(Time To First Byte)가 늘어날 수 있습니다.
3. **복잡성 증가**: 클라이언트와 서버 간 상태를 동기화하고 데이터 페칭을 효율적으로 관리하는 것이 어려울 수 있습니다. SSR과 클라이언트 로직 간의 결합을 최소화하기 위해 추가적인 설계와 노력이 필요합니다.

---

## 2. WebSocket

### Q1. WebSocket이란 무엇인가?

**A:** WebSocket은 클라이언트와 서버 간의 양방향 통신을 지원하는 네트워크 프로토콜로, HTTP와 달리 지속적인 연결을 유지하면서 실시간 데이터 전송이 가능합니다. 이는 클라이언트-서버 간 채팅, 실시간 알림, 주식 가격 업데이트와 같은 애플리케이션에서 특히 유용합니다. WebSocket은 초기 연결은 HTTP 핸드셰이크를 사용해 설정되며, 연결이 수립된 후에는 TCP를 통해 통신합니다.

### Q2. WebSocket의 특징은?

**A:**

1. **풀 듀플렉스 통신**: 클라이언트와 서버가 동시에 데이터를 주고받을 수 있어 실시간 응답 속도를 제공합니다.
2. **지속적인 연결**: 연결이 유지되므로 클라이언트가 데이터를 요청하지 않아도 서버가 데이터를 전송할 수 있습니다.
3. **낮은 오버헤드**: HTTP 요청-응답 주기를 생략하므로 네트워크 사용량을 줄이고, 반복적인 연결 설정에 따른 지연을 제거합니다.

---

## 3. 쿠키와 세션

### Q1. 쿠키란 무엇인가?

**A:** 쿠키는 클라이언트 측에 저장되는 작은 데이터 조각으로, 서버가 HTTP 응답을 통해 클라이언트에게 설정합니다. 이후 클라이언트는 모든 요청에 쿠키를 포함해 서버로 전송합니다. 이를 통해 사용자의 상태(로그인 정보 등)를 유지할 수 있습니다. `HttpOnly` 속성을 사용하면 JavaScript를 통한 쿠키 접근을 막아 XSS 공격을 방지할 수 있으며, `Secure` 속성을 추가하면 HTTPS 연결에서만 전송됩니다.

### Q2. 세션이란 무엇인가?

**A:** 세션은 서버 측에 저장되는 사용자 상태 정보로, 클라이언트는 세션 ID를 쿠키로 저장해 서버와 통신합니다. 서버는 세션 ID를 이용해 사용자 데이터를 조회하며, 세션 데이터는 주로 서버 메모리, 데이터베이스, 또는 Redis 같은 캐시 스토리지에 저장됩니다. 세션은 서버에서 관리하므로 쿠키보다 민감한 데이터 관리에 적합하며, 브라우저가 종료되면 세션이 만료되는 경우가 일반적입니다.

### Q3. 쿠키와 세션의 차이는?

**A:**

1. **저장 위치**: 쿠키는 클라이언트, 세션은 서버에 저장됩니다.
2. **보안성**: 세션은 서버에서 관리되므로 클라이언트에 저장된 데이터의 보안 문제가 없습니다.
3. **수명**: 쿠키는 설정된 만료 시간까지 유지되며, 세션은 일반적으로 브라우저 종료 시 삭제됩니다.

---

## 4. CORS (Cross-Origin Resource Sharing)

### Q1. CORS란 무엇인가?

**A:** CORS는 웹 브라우저가 다른 출처(origin)의 리소스에 대한 요청을 제한하거나 허용하는 보안 메커니즘입니다. 서버는 HTTP 응답 헤더를 통해 허용 가능한 출처, 메서드, 헤더 등을 명시하며, 브라우저는 이를 기반으로 요청을 허용하거나 차단합니다. 이 메커니즘은 보안상의 이유로 도입되었으며, 서버가 명시적으로 허용하지 않은 출처로부터의 요청은 기본적으로 차단됩니다.

### Q2. Preflight 요청이란 무엇인가?

**A:** Preflight 요청은 CORS 요청 전에 브라우저가 OPTIONS 메서드를 사용해 서버에 실제 요청을 보낼 수 있는지 확인하는 과정입니다. 브라우저는 Preflight 요청에서 허용된 메서드, 헤더, 출처 등을 확인한 뒤 요청을 보냅니다. 이 요청은 보안 검사를 위한 사전 작업으로, 서버가 명시적으로 허용하지 않으면 요청이 차단됩니다.

### Q3. Preflight 요청의 캐싱은 어떻게 관리되나요?

**A:** `Access-Control-Max-Age` 헤더를 통해 캐싱을 제어할 수 있습니다. 이 헤더는 Preflight 요청의 유효 기간을 초 단위로 설정하며, 설정된 시간 동안 동일한 요청에 대해 Preflight 요청을 생략할 수 있습니다. 브라우저 메모리에서 캐싱 데이터를 관리합니다.

---

## 5. 이미지 최적화

### Q1. 최신 이미지 포맷(WebP, AVIF)을 사용하면 얻는 이점은?

**A:**

1. **압축 효율성**: 기존 포맷(JPEG, PNG) 대비 더 작은 파일 크기를 제공하여 네트워크 전송 속도를 향상시킵니다.
2. **시각적 품질 유지**: 높은 압축율에서도 품질 손실이 적습니다.
3. **SEO 개선**: Core Web Vitals 성능 향상으로 검색 엔진 랭킹 개선에 도움을 줍니다.

### Q2. 최신 포맷을 사용하려면 별도의 인코딩이 필요한가?

**A:** 필요합니다. Node.js의 `sharp` 라이브러리나 Cloudinary 같은 이미지 처리 서비스를 사용해 손쉽게 구현할 수 있습니다. 또한 CDN을 사용하면 브라우저 호환성에 맞는 포맷을 자동으로 제공받을 수 있습니다.

---

## 6. Critical CSS

### Q1. Critical CSS란 무엇인가?

**A:** Critical CSS는 웹페이지의 초기 렌더링에 필요한 최소한의 CSS를 추출해 HTML에 인라인으로 삽입하는 기법입니다. 이를 통해 렌더링 차단 리소스 문제를 줄이고 초기 로딩 시간을 단축할 수 있습니다. 일반적으로 `critical` 같은 도구를 사용해 CSS를 추출하고, HTML의 `<head>`에 인라인으로 삽입합니다.

### Q2. React 환경에서 Critical CSS를 SSR 없이 사용하는 방법은?

**A:** React 환경에서 Critical CSS를 동적으로 적용하는 간단한 예제는 다음과 같습니다:

```javascript
useEffect(() => {
  const style = document.createElement("style");
  style.textContent = ".critical { color: red; }";
  document.head.appendChild(style);
}, []);
```

이 방식은 클라이언트에서만 동작하므로 서버 렌더링 이전에는 적용되지 않습니다. SSR을 사용하지 않는 경우, 초기 렌더링 속도 향상을 위해 이 기법을 적절히 활용할 수 있습니다.

---

## 7. 폰트 최적화

### Q1. 폰트 최적화를 구현하는 방법은?

**A:**

1. **서버 사이드 최적화**: Google Fonts API에서 `font-display: swap` 옵션을 사용하면 폰트 로딩 중 기본 폰트를 먼저 표시하여 레이아웃 이동을 줄일 수 있습니다.
2. **폰트 서브셋 생성**: 서드파티 도구를 사용해 폰트 파일에서 필요 없는 글리프를 제거하여 크기를 줄입니다.
3. **브라우저 캐싱**: CDN이나 HTTP 캐싱을 활용해 폰트를 빠르게 로드합니다.

---

## 8. 서비스 워커 (Service Worker)

### Q1. 서비스 워커란 무엇인가?

**A:** 서비스 워커는 브라우저와 네트워크 사이에서 작동하는 스크립트로, 네트워크 요청을 가로채거나 오프라인 기능을 제공할 수 있습니다. 또한 푸시 알림과 백그라운드 동작을 지원합니다. 서비스 워커는 비동기로 동작하며, 브라우저의 메인 스레드와 별도로 실행됩니다.

### Q2. Web Worker와의 차이점은?

**A:** Web Worker는 JavaScript 계산 작업을 비동기적으로 처리하기 위한 멀티스레딩 환경을 제공하며, UI 업데이트와 관련 없는 작업을 수행합니다. 반면 서비스 워커는 네트워크 요청 및 캐싱 관리에 특화된 기술로, 브라우저와 네트워크 간의 중간 계층 역할을 합니다.

### Q3. 서비스 워커의 주요 기능은?

1. **캐싱**: 요청한 리소스를 캐시하고, 네트워크가 불안정하거나 연결이 끊겼을 때도 캐시된 데이터를 반환합니다. 이를 통해 애플리케이션이 오프라인 상태에서도 작동할 수 있습니다.
2. **푸시 알림**: 서버에서 전송한 푸시 메시지를 수신하고, 사용자에게 알림을 표시합니다.
3. **백그라운드 동작**: 브라우저가 닫혀 있어도 백그라운드에서 데이터 동기화 작업을 처리할 수 있습니다.
4. **네트워크 요청 제어**: 네트워크 요청을 가로채서 수정하거나 처리 방식을 커스터마이징할 수 있습니다.

### Q4. 서비스 워커의 한계는?

- **브라우저 지원**: 모든 브라우저에서 완벽히 지원하지 않을 수 있습니다.
- **HTTPS 필요**: 보안상의 이유로 HTTPS 환경에서만 동작합니다.
- **DOM 접근 불가**: 서비스 워커는 DOM에 직접 접근할 수 없으며, 메시지 기반의 통신을 통해 메인 스레드와 상호작용합니다.
- **설치 및 업데이트**: 서비스 워커는 등록 및 활성화 단계가 필요하며, 사용자가 항상 최신 버전을 즉시 사용할 수 있도록 설계해야 합니다.

---

## 9. Cache-Control 헤더

### Q1. Cache-Control 헤더란 무엇인가?

**A:** `Cache-Control`은 HTTP 헤더로, 클라이언트와 서버 간 캐싱 정책을 설정합니다. 이를 통해 리소스의 저장, 갱신, 유효 기간 등을 제어할 수 있습니다. 주요 디렉티브는 다음과 같습니다:

1. **`max-age`**: 캐시의 유효 기간(초 단위)을 설정합니다.
2. **`no-cache`**: 캐시된 리소스를 사용하기 전에 서버와의 유효성 검사를 요구합니다.
3. **`no-store`**: 리소스를 캐시하지 않도록 설정합니다.
4. **`public`**: 모든 캐시(공유 및 개인 캐시)가 리소스를 저장할 수 있도록 허용합니다.
5. **`private`**: 개인 캐시(브라우저 캐시)에서만 리소스를 저장할 수 있도록 설정합니다.

### Q2. 백엔드에서 직접 구현하지 않아도 캐싱이 가능한가?

**A:** 가능합니다. `Cache-Control` 헤더를 설정하면 브라우저와 중간 프록시 서버가 이를 기반으로 자동으로 캐싱을 관리합니다. 그러나, 백엔드에서 캐싱된 데이터가 항상 최신 상태인지 보장해야 할 경우, 캐싱을 직접 제어하거나 `ETag`와 같은 유효성 검사 메커니즘을 추가로 구현해야 합니다.

---

## 10. React 환경에서의 Prefetch 및 코드 스플리팅

### Q1. React에서 Prefetch가 어떻게 사용되는가?

**A:** React에서는 `react-router-dom`을 통해 Prefetch 기능을 구현할 수 있습니다. 이 기능은 사용자가 특정 링크에 접근하기 전에 해당 경로에 필요한 리소스를 미리 로드하여 탐색 속도를 높입니다. 예를 들어, `link` 태그의 `rel="prefetch"` 속성을 사용하거나 `React.lazy`와 `Suspense`를 활용해 특정 컴포넌트를 미리 로드할 수 있습니다.

### Q2. React 환경에서 코드 스플리팅은 어떻게 구현되는가?

**A:** 코드 스플리팅은 `React.lazy`와 `Suspense`를 사용하여 구현합니다. 동적으로 필요한 컴포넌트만 로드하여 초기 로딩 시간을 단축할 수 있습니다. 예:

```javascript
import React, { Suspense } from "react";

const LazyComponent = React.lazy(() => import("./LazyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

### Q3. React에서 `react-router-dom` 없이 Prefetch 및 코드 스플리팅이 가능한가?

**A:** 가능합니다. Prefetch는 `fetch` API나 브라우저의 `link` 태그를 사용하여 직접 구현할 수 있습니다. 예를 들어:

```javascript
useEffect(() => {
  const prefetchData = async () => {
    await fetch("/api/some-data");
  };
  prefetchData();
}, []);
```

코드 스플리팅은 `React.lazy`를 통해 라우팅 라이브러리에 의존하지 않고도 독립적으로 구현할 수 있습니다.

---

## 11. 폰트 최적화 [CSR 환경]

### Q1. 폰트 최적화를 CSR에서 구현하는 방법은?

**A:** CSR 환경에서 폰트 최적화를 구현하려면 다음을 고려해야 합니다:

1. **Font Display 옵션**: Google Fonts 또는 CSS에서 `font-display: swap`을 사용하여 폰트 로드 중에도 텍스트를 표시할 수 있습니다.
2. **서브셋 생성**: 필요한 글리프만 포함된 경량 폰트를 생성해 사용합니다.
3. **프리로드 사용**: 중요한 폰트를 HTML `<head>`에 프리로드하여 렌더링 지연을 최소화합니다.

예제:

```html
<link
  rel="preload"
  href="/fonts/my-font.woff2"
  as="font"
  type="font/woff2"
  crossorigin="anonymous"
/>
<style>
  @font-face {
    font-family: "MyFont";
    src: url("/fonts/my-font.woff2") format("woff2");
    font-display: swap;
  }
</style>
```

---

위 내용을 기반으로, 각 질문에 대한 더 세부적인 정보나 실습 예제가 필요하면 말씀해주세요.
